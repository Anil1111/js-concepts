<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>JavaScript Concepts ü§î</title>
	</head>
	<body>
		<h1>
			Open your browser console üíÅ
		</h1>
		<script>
			// ************************************************************************************************
			// Welcome! All console logs are commented out, so just uncomment the ones for the topic you're on!
			// Feel free to add anything, good luck!
			// ************************************************************************************************

			// ---------- comparisons ----------
			const nan = NaN == NaN
			// false. NaN is not equal to itself
			const doubleEquals = 77 == '77'
			// true! JS converts it to the same type for us. == compares the content
			const tripleEquals = 77 === '77'
			// false! they are not the same type. === compares type AND content

			// ---------- 'this' keyword ----------
			const car = {
				make: 'Toyota',
				passengers: 5,
				getPassengersRegular: function () {
					return this.passengers
				},
				getPassengersArrow: () => {
					return this.passengers
				},
			}
			const passengers = car.getPassengersRegular()
			// 5, as you would expect!
			const morePassengers = car.getPassengersArrow()
			// undefined! the 'this' arrow function cannot access the object itself

			// ---------- unary operator ----------
			const stringResult = 1 + '2'
			// 12 as a string, the 1 is converted to a string and then concatenated
			const unaryResult = 1 + +'2'
			// 3 as a number ü§î the second + is a unary, so '2' is converted to a number and incremented

			// ---------- timeouts ---------- https://youtu.be/USbiLiF9NDY
			// console.log('first')
			const timeoutTest = setTimeout(function () {
				// console.log('fourth')
			}, 1)
			const anotherTimeoutTest = setTimeout(function () {
				// console.log('third')
			}, 0)
			// console.log('second')
			// timeouts are taken away from the main event loop, meaning they will run after any other console logs

			// ---------- async/await ---------- https://youtu.be/j1ykOrC2f0A
			let asyncNum = 0
			async function increment() {
				asyncNum += await 2 // stores 0 in asyncNum, then waits for rest of the stack to finish before adding 2 to make 2
				// console.log(asyncNum)
			}
			increment()
			asyncNum += 1
			// console.log(asyncNum) // runs before the console log in increment(), prints 1
			// console shows 1, then 2

			// ---------- revealing module pattern ---------- https://youtu.be/e0u8z-9aAEw
			// this is an IIFE - Immediately Invoked Functional Expression
			let personalInfo = (function () {
				let pets = ['Linus', 'Cody']
				let name = function () {
					// console.log('Matt Hughes')
				}
				let twitter = function () {
					// console.log('@matthughes2112')
				}
				// these inside functions/items cease to exist once the function is over, so we need to return them üòä
				return {
					name,
					pets,
				}
			})()
			// so outside of the function, we can use the returned 'name' method and 'pets' array, but NOT the 'twitter' method
			personalInfo.name()
			personalInfo.pets.push('Froyd')
			// personalInfo.twitter() would NOT work since it hasn't been returned to the main window

			// ---------- function parameters ---------- https://youtu.be/WyxU9MzUwOw
			// make sure the function has recieved the correct number of arguments
			let twoArguments = function (a, b) {
				// 'arguments' is built in, and contains all the passed arguments!
				// the function length represents the number of arguments that are required
				if (arguments.length === twoArguments.length) {
					// console.log(`The two arguments are ${a} and ${b}`)
				}
			}
			twoArguments(1) // too few arguments
			twoArguments(1, 2) // juuuuuust right!
			twoArguments(1, 2, 3) // too many arguments

			// ---------- singletons ---------- https://youtu.be/VlTlAAOBlzI
			// this is an object that will create an instance, or, if an instance has already been created, will give a ref to that instance üò¶
			let objectToCreate = (function () {
				let theInstance // private instance variable
				function create() {
					// if not created yet, let's create it!
					return {
						// return the newly created object!
						singletonObject: {
							name: 'Matt',
						},
					}
				}
				return {
					getInstance: function () {
						// first, let's check to see if an isntance exists already...
						if (!theInstance) {
							theInstance = create()
						}
						return theInstance
					},
				}
			})()

			// ---------- closures ---------- https://youtu.be/0iflBympZ1E
			function closure(a) {
				let b = 2
				setTimeout(function () {
					// console.log(a, b)
				}, 1000)
			}
			closure(1)
			// this will wait a second, then print out 1 and 2

			function f2() {
				for (var i = 0; i < 3; i++) {
					setTimeout(function () {
						// console.log(i)
					}, 1000 * i)
				}
			}
			f2()
			// this will print 3 multiple times, since the var i is incremented all the way to 3 before the timeout of 1000ms has gone by
			// to fix, change var to let üòä var i means i is scoped to global/function, let i means i is scoped to just the setTimeout

			// ---------- Array.from ---------- https://youtu.be/PQAuy0e0TFg
			const randomArray = Array.from({ length: 5 }, (element) => Math.random())
			// since all arrays have a built-in property called 'length', we can predefine that using an object property!
			// the second parameter takes a map function, so we can do whatever we like with that! (like random numbers)

			const anotherRandomArray = new Array(5)
				.fill(null)
				.map((element) => Math.random())
			// or, we can use 'new' and pass it a length! then use fill to populate it, then map to change all the nulls to rando numbers!
			// both ways accomplish the same end result

			// ---------- var versus let - hoisting ---------- https://youtu.be/7CDUeZh5OCE
			// when vars are hoisted, they are assigned as undefined
			// when lets are hoisted, they are not assigned anything at all!

			// console.log('var: ', varTest) // logs undefined
			// console.log('let: ', letTest) // gives us an error üôÅ
			var varTest = 'var worked!'
			let letTest = 'let worked!'

			// ---------- generate a random hex color ---------- https://youtu.be/6wNt8B8aH80
			function generateColor() {
				let randomNum = Math.random()
				randomNum = randomNum.toString(16) // by passing a radix/base of 16 to the toString method, it converts the random number to hex!
				return '#' + randomNum.substring(2, 8) // use substring so something like 0.54f6a68d7 is converted to 54f6a6 üòÑ
			}

			// ---------- map & parseInt() ---------- https://youtu.be/U0WewGAnhNg

			//Why do we get this weird result from the map method?
			// myarray.map(func);
			//We want to convert 3 strings into numbers

			let badResult = ['7', '8', '9'].map(parseInt) // returns [7, NaN, NaN], since this map will pass the whole array to parseInt
			let goodResult = ['7', '8', '9'].map((int) => parseInt(int)) // returns [7, 8, 9] , since this map will pass one int at a time to parseInt

			// ---------- object.property versus object[property] ---------- https://youtu.be/D_ESB34x-Wo
			// Differences between dot notation and square bracket syntax

			let companies = {
				auto: 'honda',
			}
			let cars = {
				honda: 'accord',
				toyota: '4runner',
			}

			// which of these will work? remember, JS will run [] code first, starting from the inside -> outside
			// console.log(cars[companies.auto]) // works! the companies.auto converts to 'honda', so cars['honda']
			// console.log(cars.companies.auto) // does not work! cars does not have .companies üò¶
			// console.log(cars[companies['auto']]) // works! the companies['auto'] converts to 'honda', so cars['honda'] again
			// console.log(cars[companies[auto]]) // does not work! auto is in [], so it runs first. auto on its own does not exist anywhere!

			// ---------- functions & 'this' ---------- https://youtu.be/DlN8ECKjaJw
			// Using `this` inside an object
			// The object has functions created three different ways
			// What will be the result of the three log statements?

			const circle = {
				radius: 10,
				fullFunction: function () {
					return this.radius // works! the reference for 'this' is whatever called it, so circle! (which has .radius)
				},
				shorthandFunction() {
					return this.radius // also works! same as above, but the shorthand version
				},
				arrowFunction: () => {
					return this.radius // nope! arrowFunction will be looking at the global scope! which does not have anything called 'radius'
				},
			}

			// ---------- is it an anagram? ---------- https://youtu.be/YCpxWfxU0NQ
			let isAnagram = function (string1, string2) {
				return (
					string1.split('').sort().join('').toLowerCase() ===
					string2.split('').sort().join('').toLowerCase()
				)
				// split the string into an array of letters -> sort that array -> join that array into a string -> make it case insensitive üòä
			}

			// console.log(isAnagram('hello', 'jello')) // false
			// console.log(isAnagram('hello', 'loelh')) // true

			// ---------- largest difference between two ints ---------- https://youtu.be/tM40K-JO_tA
			let numbers = [12, 2, 6, 5, 9, 10, 33]

			let difference = (function (arr) {
				return Math.max(...arr) - Math.min(...arr)
				// simple subtract the Min of the array from the Max of the array!
				// it's easy using Math.max and the spread ... operator to pass in the array!
			})(numbers)

			// ---------- panlindromes! (my favorite) ---------- https://youtu.be/saj9KQ3wGtc
			// is the word (string) spelled the same forwards and backwards?

			const isPalindrome = (word) => {
				return (
					word.toLowerCase() === word.split('').reverse().join('').toLowerCase()
				)
				// similar to anagrams, is the original word equal to...
				// the original word split into an array of letters -> reversed -> joined into a string again -> and lowercased?
				// if so, it's a palindrome! üòÅ
			}

			// console.log(isPalindrome('racecar'))     // true
			// console.log(isPalindrome('boat'))        // false
			// console.log(isPalindrome('Radar'))       // true

			// ---------- variable chain definitions & scope ---------- https://youtu.be/fWS0Q2jyC_8
			// this is a tough one, take it one line at a time
			function varChain() {
				var a = 1,
					b = 1
				var x = (y = 2)
			}
			function letChain() {
				let j = 1,
					k = 1
				let r = (s = 2)
			}
			varChain()
			letChain()

			console.log(window.a)
			// first off, we know a, x, j, & r will be undefined outside of the function
			// this is because they all immediately follow an assignment like var or let
			// but what about b, y, k & s? are they affected by the var or let at the beginning of their line?
			// with a comma, yes! so b is affected by var, and k is affected by let. they are both defined within their functions
			// y and s both work üò≤
			// since var and let are not applied after the second = on those lines, so JS uses var in the global scope to be safe!
		</script>
	</body>
</html>
