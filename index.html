<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>JavaScript Concepts ü§î</title>
	</head>
	<body>
		<h1>
			Open your browser console üíÅ
		</h1>
		<script>
			// ************************************************************************************************
			// Welcome! All console logs are commented out, so just uncomment the ones for the topic you're on!
			// Feel free to add anything, good luck!
			// ************************************************************************************************

			// ---------- comparisons ----------
			const nan = NaN == NaN
			// false. NaN is not equal to itself
			const doubleEquals = 77 == '77'
			// true! JS converts it to the same type for us. == compares the content
			const tripleEquals = 77 === '77'
			// false! they are not the same type. === compares type AND content

			// ---------- 'this' keyword ----------
			const car = {
				make: 'Toyota',
				passengers: 5,
				getPassengersRegular: function () {
					return this.passengers
				},
				getPassengersArrow: () => {
					return this.passengers
				},
			}
			const passengers = car.getPassengersRegular()
			// 5, as you would expect!
			const morePassengers = car.getPassengersArrow()
			// undefined! the 'this' arrow function cannot access the object itself

			// ---------- unary operator ----------
			const stringResult = 1 + '2'
			// 12 as a string, the 1 is converted to a string and then concatenated
			const unaryResult = 1 + +'2'
			// 3 as a number ü§î the second + is a unary, so '2' is converted to a number and incremented

			// ---------- timeouts ---------- https://youtu.be/USbiLiF9NDY
			// console.log('first')
			const timeoutTest = setTimeout(function () {
				// console.log('fourth')
			}, 1)
			const anotherTimeoutTest = setTimeout(function () {
				// console.log('third')
			}, 0)
			// console.log('second')
			// timeouts are taken away from the main event loop, meaning they will run after any other console logs

			// ---------- async/await ---------- https://youtu.be/j1ykOrC2f0A
			let asyncNum = 0
			async function increment() {
				asyncNum += await 2 // stores 0 in asyncNum, then waits for rest of the stack to finish before adding 2 to make 2
				// console.log(asyncNum)
			}
			increment()
			asyncNum += 1
			// console.log(asyncNum) // runs before the console log in increment(), prints 1
			// console shows 1, then 2

			// ---------- revealing module pattern ---------- https://youtu.be/e0u8z-9aAEw
			// this is an IIFE - Immediately Invoked Functional Expression
			let personalInfo = (function () {
				let pets = ['Linus', 'Cody']
				let name = function () {
					// console.log('Matt Hughes')
				}
				let twitter = function () {
					// console.log('@matthughes2112')
				}
				// these inside functions/items cease to exist once the function is over, so we need to return them üòä
				return {
					name,
					pets,
				}
			})()
			// so outside of the function, we can use the returned 'name' method and 'pets' array, but NOT the 'twitter' method
			personalInfo.name()
			personalInfo.pets.push('Froyd')
			// personalInfo.twitter() would NOT work since it hasn't been returned to the main window

			// ---------- function parameters ---------- https://youtu.be/WyxU9MzUwOw
			// make sure the function has recieved the correct number of arguments
			let twoArguments = function (a, b) {
				// 'arguments' is built in, and contains all the passed arguments!
				// the function length represents the number of arguments that are required
				if (arguments.length === twoArguments.length) {
					// console.log(`The two arguments are ${a} and ${b}`)
				}
			}
			twoArguments(1) // too few arguments
			twoArguments(1, 2) // juuuuuust right!
			twoArguments(1, 2, 3) // too many arguments

			// ---------- singletons ---------- https://youtu.be/VlTlAAOBlzI
			// this is an object that will create an instance, or, if an instance has already been created, will give a ref to that instance üò¶
			let objectToCreate = (function () {
				let theInstance // private instance variable
				function create() {
					// if not created yet, let's create it!
					return {
						// return the newly created object!
						singletonObject: {
							name: 'Matt',
						},
					}
				}
				return {
					getInstance: function () {
						// first, let's check to see if an isntance exists already...
						if (!theInstance) {
							theInstance = create()
						}
						return theInstance
					},
				}
			})()

			// ---------- closures ---------- https://youtu.be/0iflBympZ1E
			function closure(a) {
				let b = 2
				setTimeout(function () {
					// console.log(a, b)
				}, 1000)
			}
			closure(1)
			// this will wait a second, then print out 1 and 2

			function f2() {
				for (var i = 0; i < 3; i++) {
					setTimeout(function () {
						// console.log(i)
					}, 1000 * i)
				}
			}
			f2()
			// this will print 3 multiple times, since the var i is incremented all the way to 3 before the timeout of 1000ms has gone by
			// to fix, change var to let üòä var i means i is scoped to global/function, let i means i is scoped to just the setTimeout

			// ---------- Array.from ---------- https://youtu.be/PQAuy0e0TFg
			const randomArray = Array.from({ length: 5 }, (element) => Math.random())
			// since all arrays have a built-in property called 'length', we can predefine that using an object property!
			// the second parameter takes a map function, so we can do whatever we like with that! (like random numbers)

			const anotherRandomArray = new Array(5)
				.fill(null)
				.map((element) => Math.random())
			// or, we can use 'new' and pass it a length! then use fill to populate it, then map to change all the nulls to rando numbers!
			// both ways accomplish the same end result

			// ---------- var versus let - hoisting ---------- https://youtu.be/7CDUeZh5OCE
			// console.log('var: ', varTest)
			// console.log('let: ', letTest)
			var varTest = 'var worked!'
			let letTest = 'let worked!'
		</script>
	</body>
</html>
